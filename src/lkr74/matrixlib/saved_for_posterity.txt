            // alternative depermutation code for NSPMatrix.backsubstituteLU()

       		for (int i = 0, offVi = 0; i < N; i++) {

			boolean bImatch = offVi < nNodes && bVspB[offVi].r == i ? true : false;
			// the permutations of decomposition stage need to be unpermuted during the passes
			int ip = mutatorLU[i];
			int offVip = findHVspNode(bVspB, 0, nNodes - 1, ip, -1);				// see if b[ip] exists in sparse array
			if (offVip >= 0) {														// if b[ip] is a non-zero, existing node...
				sum = bVspB[offVip].v;												// sum = b[ip]
				if (bImatch)														// if b[i] matches current row index i (thus is non-zero)
					bVspB[offVip].v = bVspB[offVi].v;								// b[ip] = b[i] (assigning to existing node)
				else {
					removeLocalHVspNode(aVspB, offVip, 1);							// if assigning to a zero, remove the node
					nNodes = aVspB.nodes;
					vectorB.nNZ--;
					bVspB = aVspB.array;
				}
			} else {
				sum = 0;
				if (bImatch) {														// create node b[ip] only if b[i] is nonzero
					NspNode newNode = bVspB[offVi].clone();
					newNode.r = ip;
					insertLocalHVspNode(aVspB, -offVip-1, 1, newNode);				// b[ip] = b[i]	(assigning by inserting a node)
					insertLocalHVspNode(vectorB.Hsp[ip], 0, 0, newNode);
					nNodes = aVspB.nodes;
					vectorB.nNZ++;
					bVspB = aVspB.array;
				}
			}

			if (ii >= 0)
				sum -= multiplyStartEndHVsp(bLU[1].Hsp[i], aVspB, 0, 1, ii, i - 1);	// for (ii <= j < i), sum -= a[i][j] * b[j]
			else
				if (!nearZero(sum)) ii = i;					// nonzero element found, we'll have to do the sums in loop above from now on

			if (bImatch) {
				if (nearZero(sum))	{
					removeLocalHVspNode(aVspB, offVi, 1);							// b[i] = sum (b[i] exists as nonzero, but is assigned a zero)
					bVspB = aVspB.array;
					vectorB.nNZ--;
				} else bVspB[offVi].v = sum;										// b[i] = sum (simple assignment if b[i] exists as non-zero)
				offVi++;
			} else {
				if (!nearZero(sum)) {
					NspNode newNode = new NspNode(i, 0, sum, 0, offVi, 0);
					insertLocalHVspNode(aVspB, offVi, 1, newNode);					// b[i] = sum (b[i] was zero/nonexistent, assigned value was nonzero)
					insertLocalHVspNode(vectorB.Hsp[i], 0, 0, newNode);				// insert also to horisontal aspect
					bVspB = aVspB.array;
					vectorB.nNZ++;
				}																	// b[i] = sum (b[i] was zero and assignment was zero, nothing happens)
			}
		}

 		NspNode[] pivotNspA = bLU[1].pivotNsp;
		for (int i = N - 1, offVi = nNodes - 1; i >= 0; i--) {						// backsubstitution pass

			while (offVi > 0 && bVspB[offVi].r > i) offVi--;						// seek backwards in sparse array for a row matching or below i
			boolean bImatch = (bVspB[offVi].r == i ? true : false);
			if (bImatch)	sum = bVspB[offVi].v;									// sum = b[i] (zero if b[0] is nonexistante/zero value
			else 			sum = 0;
			sum -= multiplyStartEndHVsp(lHspLU[i], aVspB, 0, 1, ii, i - 1);			// for (i+1 <= j < N), sum -= a[i][j] * b[j]

			// store an element of solution vector X
			if (bImatch)
				if (nearZero(sum)) {
					removeLocalHVspNode(aVspB, offVi, 1);							// if assigning node to a zero, remove that node
					nNodes = aVspB.nodes;
					bLU[0].nNZ--;
					bVspB = aVspB.array;
				} else
					bVspB[offVi].v = sum / pivotNspA[i].v;							// b[i] = sum / a[i][i] (case when b[i] exists as nonzero value)
			else {
				if (!nearZero(sum)) {
					NspNode newNode = new NspNode(i, 0, sum / pivotNspA[i].v, 0, offVi, 0);
					insertLocalHVspNode(aVspB, offVi, 1, newNode);					// b[i] = sum / a[i][i] (b[i] is zero/nonexistent, insert new node
					insertLocalHVspNode(vectorB.Hsp[i], 0, 0, newNode);				// insert also to horisontal aspect
					bLU[0].nNZ++;
				}
			}
		}










	// factorises/decomposes matrix into two diagonal matrices U and V, useful for the LU backsubstitution linear solving method:
	//		uuu			v..
	// U:	.uu		L:	vv.
	//		..u			vvv
	// TODO: debugging needed, do not use
	public Matrix[] decomposeLU() {
		
		if (M != N)	throw new RuntimeException("Matrix.decomposeLU(): Matrix not square.");
		if (M < 1)	throw new RuntimeException("Matrix.decomposeLU(): Invalid matrix.");

		// all diagonal elements must be nonzero
		for (int d = 0; d < M; d++)
			if (nearZero(data[d * M + d])) { status |= SINGULAR_MATRIX; return null; }
			
		Matrix[] lLU = new Matrix[2];
		lLU[0] = new Matrix("L", M, N, Matrix.Type.Null);
		lLU[1] = new Matrix("U", M, N, Matrix.Type.Null);
		double[] dataL = lLU[0].data, dataU = lLU[1].data;

		for (int c1 = 0; c1 < N; c1++) {
			
			// calculate u(r,c)
			if (c1 == 0)	dataU[0] = data[0];
			else
				for (int r = 0; r <= c1; r++) {
					int rN = r * N;
					double luSum = 0;
					for (int k = 0; k < r; k++)
						luSum += dataL[rN + k] * dataU[k * N + c1];
					dataU[rN + c1] = data[rN + c1] - luSum;
				}
			
			// calculate l(r,c)
			double uDiag = 1.0 / dataU[c1 * N + c1];
			for (int r = c1; r < N; r++) {
				int rN = r * N;
				double luSum = 0;
				if (c1 == 0) dataL[rN] = data[rN];
				else {
					for (int k = 0; k < c1; k++)
						luSum += dataL[rN + k] * dataU[k * N + c1];
					dataL[rN + c1] = (data[rN + c1] - luSum) * uDiag;
				}
			}
		}
		
		if (DEBUG_LEVEL > 1) {
			System.out.println("decomposeLU() result:");
			System.out.println(lLU[0].toString());
			System.out.println(lLU[1].toString());
		}
		return lLU;
	}
	
	
	
		
	// method takes the factorised L & U triangular matrices applying them on this constant vector to solve
	// a linear system where only the constant vector is changing, the matrix coefficients assumed to be fixed
	// method returns the solution vector x
	public Matrix backSubstituteLU(Matrix L, Matrix U) {
		
		Matrix cp = new Matrix("c'", U.M, 1, Matrix.Type.Null);					// c' needs to be generated from input constant vector c
		String newname;
		if (Matrix.DEBUG_LEVEL > 1) newname = "x((LU)^-1*" + this.name + ")";
		else						newname = "x";
		Matrix x = new Matrix(newname, U.M, 1, Matrix.Type.Null);									// the solution vector x
		double[] dataU = U.data, dataV = L.data, datacp = cp.data, datax = x.data;

		// loop handles every element of c, c', V, U and x
		// c'(r) = (c(r) - sum(v(r,k) * c'(k))) / v(r,r)
		datacp[0] = data[0] / dataV[0];
		for (int r = 1; r < M; r++) {
			int rN = L.N * r;
			double sum = 0;
			for (int k = 0; k < r; k++) sum += dataV[rN + k] * datacp[k];
			datacp[r] = (data[r] - sum) / dataV[rN + r];
		}

		// x(r) = (c'(r) - sum(u(r,k) * x(k))) / u(r,r)
		int r = M - 1;
		datax[r] = datacp[r] / dataU[r * U.N + r--];
		for (; r >= 0; r--) {
			int rN = U.N * r;
			double sum = 0;
			for (int k = r + 1; k < M; k++) sum += dataU[rN + k] * datax[k];
			datax[r] = (datacp[r] - sum) / dataU[rN + r];
		}

		if (DEBUG_LEVEL > 1) {
			System.out.println("backSubstituteLU solver:");
			System.out.println(x.toString());
		}
		return x;	
	}
	



	private static DoubleBuffer bufSWA, bufSWB, bufSWC;	// preallocated DirectBuffer for operations upto specific matrix size
	
	// method preallocates a DirectBuffer for a matrix operation of a certain size with a certain recursion cutoff
	public static boolean allocateStrasWin(int Mreqsize, int truncP) {

		if (Mreqsize < 2) throw new RuntimeException("Matrix.allocateStrasWin(): Invalid matrix dimensions.");
		if (truncP < 2) throw new RuntimeException("Matrix.allocateStrasWin(): Invalid truncation point.");
		if (truncP > Mreqsize) truncP = Mreqsize;
		
		int Msize = 2, memSize = 0;
		// do 2^(n+1) until we reach truncation point (to make sure we'll encompass the smallest submatrix size)
		for (; Msize < truncP; Msize <<= 1);		
		for (; Msize < Mreqsize; Msize <<= 1)		// do 2^(n+1) until we reach or excel the provided matrix size
			memSize += truncP * truncP * 8;			// we need 8 allocations per recursion level/submatrix
		memSize += Msize * Msize * 2;				// Matrix A & B will also be copied to direct buffer
		
		bufSWA = ByteBuffer.allocateDirect(memSize * 8).asDoubleBuffer();
		if (DEBUG_LEVEL > 2)
	        System.out.println("bufSW is direct: " + bufSWA.isDirect() + "and has " + (bufSWA.hasArray() ? "a" : "no") + "backing array.");
		return true;
	}




	public static Matrix multiplyStrasWin(Matrix A, Matrix B, int truncP, boolean useDBversion) {
		
		if (A.M < 1 || A.N < 1 || B.M < 1 || B.N < 1) throw new RuntimeException("Matrix.multiply(): Invalid matrix dimensions.");
		if (A.N != B.M) throw new RuntimeException("Matrix.multiply(): Nonmatching matrix dimensions.");
		mulSW_DEBUG = mulFlopsSW_DEBUG = mulAdopsSW_DEBUG = 0;
				
		// squarify and expand matrices to nearest 2^n size
		int majorM = A.M > A.N ? A.M : A.N, newM;
		for (newM = 2; newM < majorM; newM <<= 1);		// do 2^(n+1) until we reach or excel major size of the matrices
		if (A.M != A.N || newM != majorM) {
			A = A.rescale(0, 0, newM, newM, false);		// no BitImage needed for transient data
			B = B.rescale(0, 0, newM, newM, false);
		}
		if (truncP > newM) truncP = newM;				// truncation point can't be larger than the matrix

		String newname;
		if (Matrix.DEBUG_LEVEL > 1) newname = "(" + A.name + "." + B.name + ")";
		else						newname = "W" + Matrix.nameCount++;
		Matrix C = new Matrix(newname, newM, newM, Matrix.Type.Null);
		
		if (useDBversion) {
			int Msize = newM * newM;
			bufSWA.get(A.data, 0, Msize);
			bufSWA.reset();
			bufSWB = bufSWA.duplicate();
			bufSWC = bufSWA.duplicate();
			bufSWB.position(Msize).mark();
			bufSWB.get(B.data, Msize, Msize);
			bufSWB.reset();
			bufSWC.position(Msize << 1).mark();
			// at start, offsA,offsB,offsC point to A, B, C matrix data offsets, the submatrices offset points beyond those three
			int[] subInfo = {truncP, newM, 0, Msize, Msize << 1, newM, newM, newM, Msize * 3};
			//multiplyStrasWin2DB(bufSWA, bufSWB, bufSWC, subInfo);
			bufSWC.reset();
			bufSWC.put(C.data, Msize << 1, Msize);
		} else {

			buffer2x2StrasWin = new double[8][truncP > 16 ? 16*16 : truncP*truncP];
			
			// subInfo carries along following data:
			// (truncP) the matrix size truncation point when standard multiplicator is used instead
			// (dim) the current submatrix dimension 
			// 3x offsets into the flat datafields, 3x the matrix width of the datafields
			int[] subInfo = {truncP, newM, 0, 0, 0, newM, newM, newM};
			multiplyStrasWin2(A.data, B.data, C.data, subInfo);
		}
		if (DEBUG_LEVEL > 1) System.out.println(C.toString());
		return C;

	}



	// the preallocated DirectBuffer version of Strassen-Winograd multiplier, using bufSWA, bufSWB, bufSWC pointers
//	public static void multiplyStrasWin2DB(DoubleBuffer dA, DoubleBuffer dB, DoubleBuffer dC, int[] subInfo) {
//
//		int truncP = subInfo[0], dim = subInfo[1], offset = subInfo[8];
//		int offsA = subInfo[2], offsB = subInfo[3], offsC = subInfo[4];
//		int dimA = subInfo[5], dimB = subInfo[6], dimC = subInfo[7];
//		Matrix.mulSW_DEBUG++;
//		Matrix.mulFlopsSW_DEBUG += 4;
//
//		// if we reached base case of 2x2, return straight 2x2 multiplication
//		if (dim == 2) {
//			dA.position(offsA);
//			dB.position(offsB);
//			dC.position(offsC);
//			double a11 = dA.get(), a12 = dA.get(), a21 = dA.get(offsA + dimA), a22 = dA.get(offsA + dimA + 1);
//			double b11 = dB.get(), b12 = dB.get(), b21 = dB.get(offsB + dimB), b22 = dB.get(offsB + dimB + 1);
//			dC.put(a11 * b11 + a12 * b21);
//			dC.put(a11 * b12 + a12 * b22);
//			dC.position(offsC + dimC);
//			dC.put(a21 * b11 + a22 * b21);
//			dC.put(a21 * b12 + a22 * b22);
//			Matrix.mulFlopsSW_DEBUG += 8;
//			Matrix.mulAdopsSW_DEBUG += 11;
//			return;
//		}
//		
//		// if we reached the recursion truncation point, multiply current submatrix with standard algorithm
//		if (truncP >= dim) {
//			Matrix.mulFlopsSW_DEBUG += dim * 2 + dim * dim + dim * dim * dim;
//			Matrix.mulAdopsSW_DEBUG += dim * 2 + dim * dim + dim * dim * dim * 2;
//			
//			for (int i = 0; i < dim; i++) {
//				int ioffsA = offsA + i * dimA, ioffsC = offsC + i * dimC;
//				for (int j = 0; j < dim; j++) {
//					dA.position(ioffsA + j);
//					dB.position(offsB + j * dimB);
//					dC.position(ioffsC);
//					double v = dA.get();
//					if (v < -Matrix.ROUNDOFF_ERROR || v > Matrix.ROUNDOFF_ERROR) {
//						for (int k = 0; k < dim; k++)
//							dC.put(ioffsC + k, dC.get() + v * dB.get());
//					}
//				}
//			}		
//			return;
//		}
//		
//		int sdim2 = dim>>1, size = dim * dim, ssize = size>>2;		// next sublevel dimensions
//		// offsets to middle row (half-way into submatrix) of current recursive level
//		int hoffsA = dimA * sdim2, hoffsB = dimB * sdim2, hoffsC = dimC * sdim2;
//		// the skips tell how many steps to skip to get to next row in the data during incremental operations
//		int skipA = dimA - sdim2, skipB = dimB - sdim2, skipC = dimC - sdim2;
//
//		// A21 + A22 -> S1
//		DoubleBuffer dS1 = dA.duplicate();
//		dS1.position(offset);
//		for (int i = 0, offsA21 = offsA + hoffsA, offsA22 = offsA21 + sdim2; i < sdim2; i++)  {
//			for (int j = 0; j < sdim2; j++)	 dS1.put(dA.get(offsA21++) + dA.get(offsA22++));
//			offsA21 += skipA; offsA22 += skipA;
//		}
//
//		// B12 - B11 -> T1
//		DoubleBuffer dT1 = dA.duplicate();
//		int offsetT1 = offset + ssize;
//		dT1.position(offsetT1);
//		for (int i = 0, offsB11 = offsB, offsB12 = offsB + sdim2; i < sdim2; i++)  {
//			for (int j = 0; j < sdim2; j++)	 dT1.put(dB.get(offsB12++) - dB.get(offsB11++));
//			offsB12 += skipB; offsB11 += skipB;
//		}
//
//		// S1 . T1 -> P5
//		DoubleBuffer dP5 = dA.duplicate();
//		int offsetP5 = offsetT1 + ssize;
//		int[] subInfo3 = {truncP, sdim2, offset, offsetT1, offsetP5, sdim2, sdim2, sdim2, offset + ssize * 8};
//		multiplyStrasWin2DB(dS1, dT1, dP5, subInfo3);
//
//		// B22 - T1 -> T2 (=T1)
//		DoubleBuffer dT2 = dT1;
//		dT2.position(offsetT1);
//		for (int i = 0, offsB22 = offsB + hoffsB + sdim2, offs = offsetT1; i < sdim2; i++)  {
//			for (int j = 0; j < sdim2; j++, offs++)	 dT2.put(dB.get(offsB22++) - dT1.get(offs++));
//			offsB22 += skipB;
//		}
//
//		// S1 - A11 -> S2 (=S1)
//		DoubleBuffer dS2 = dS1;
//		dS2.position(offset);
//		for (int i = 0, offsA11 = offsA, offs = offset; i < sdim2; i++)  {
//			for (int j = 0; j < sdim2; j++, offs++)	dS2.put(dS1.get(offs++) - dA.get(offsA11++));
//			offsA11 += skipA;
//		}
//			
//		// S2 . T2 -> P6
//		DoubleBuffer dP6 = dA.duplicate();
//		int offsetP6 = offsetP5 + ssize;
//		subInfo[4] = offsetP6;
//		multiplyStrasWin2DB(dS2, dT2, dP6, subInfo3);
//
//		// A12 - S2 -> S4
//		DoubleBuffer dS4 = dA.duplicate();
//		int offsetS4 = offsetP6 + ssize;
//		dS2.position(offset);
//		dS4.position(offsetS4);
//		for (int i = 0, offsA12 = offsA + sdim2, offs = 0; i < sdim2; i++)  {
//			for (int j = 0; j < sdim2; j++, offs++)	 dS4.put(dA.get(offsA12++) - dS2.get());
//			offsA12 += skipA;
//		}
//
//		// S4 . B22 -> P3
//		DoubleBuffer dP3 = dA.duplicate();
//		int[] subInfo5 = {truncP, sdim2, 0, offsB + hoffsB + sdim2, 0, sdim2, dimB, sdim2};
//		multiplyStrasWin2DB(dS4, dB, dP3, subInfo5);
//
//		// A11 - A21 -> S3 (=S1=S2)
//		double[] dS3 = dS2;
//		for (int i = 0, offsA11 = offsA, offsA21 = offsA + hoffsA, offs = 0; i < sdim2; i++)  {
//			for (int j = 0; j < sdim2; j++, offs++)	 dS3[offs] = dA[offsA11++] - dA[offsA21++];
//			offsA11 += skipA; offsA21 += skipA;
//		}
//		
//		// B22 - B12 -> T3 (=S4)
//		double[] dT3 = dS4;
//		for (int i = 0, offsB12 = offsB + sdim2, offsB22 = offsB12 + hoffsB, offs = 0; i < sdim2; i++)  {
//			for (int j = 0; j < sdim2; j++, offs++)	 dT3[offs] = dB[offsB22++] - dB[offsB12++];
//			offsB22 += skipB; offsB12 += skipB;
//		}
//
//		// T2 - B21 -> T4 (=T1=T2)
//		double[] dT4 = dT2;
//		for (int i = 0, offsB21 = offsB + hoffsB, offs = 0; i < sdim2; i++)  {
//			for (int j = 0; j < sdim2; j++, offs++)	 dT4[offs] = dT2[offs] - dB[offsB21++];
//			offsB21 += skipB;
//		}
//
//		// A11 . B11 -> P1
//		int[] subInfo2 = {truncP, sdim2, offsA, offsB, 0, dimA, dimB, sdim2};
//		double[] dP1 = (sdim2 == 2 ? buffer2x2StrasWin[6] : new double[ssize]);
//		multiplyStrasWin2(dA, dB, dP1, subInfo2);
//
//		// S3 . T3 -> P7
//		double[] dP7 = (sdim2 == 2 ? buffer2x2StrasWin[7] : new double[ssize]);
//		multiplyStrasWin2(dS3, dT3, dP7, subInfo3);
//
//		// P1 + P6 -> U2 (=T3=S4)
//		double[] dU2 = dT3;
//		for (int i = 0, offs = 0; i < sdim2; i++)  {
//			for (int j = 0; j < sdim2; j++, offs++)	dU2[offs] = dP1[offs] + dP6[offs];
//		}
//
//		// A12 . B21 -> P2 (=P6)
//		subInfo2[2] += sdim2;
//		subInfo2[3] += hoffsB;
//		double[] dP2 = dP6;
//		multiplyStrasWin2(dA, dB, dP2, subInfo2);
//
//		// P1 + P2 -> C11
//		for (int i = 0, offsC11 = offsC, offs = 0; i < sdim2; i++)  {
//			for (int j = 0; j < sdim2; j++, offs++)	dC[offsC11++] = dP1[offs] + dP2[offs];
//			offsC11 += skipC;
//		}
//
//		// A22 . T4 -> P4 (=P2)
//		double[] dP4 = dP2;
//		subInfo2[2] = offsA + hoffsA + sdim2;
//		subInfo2[3] = 0;
//		subInfo2[5] = dimA;
//		subInfo2[6] = sdim2;
//		multiplyStrasWin2(dA, dT4, dP4, subInfo2);
//							
//		// U2 + P7 -> U3 (=T1=T2=T4)
//		double[] dU3 = dT4;
//		for (int i = 0, offs = 0; i < sdim2; i++)  {
//			for (int j = 0; j < sdim2; j++, offs++)	dU3[offs] = dU2[offs] + dP7[offs];
//		}
//
//		// U2 + P5 -> U4 (=S1=S2=S3)
//		double[] dU4 = dS3;
//		for (int i = 0, offs = 0; i < sdim2; i++)  {
//			for (int j = 0; j < sdim2; j++, offs++)	dU4[offs] = dU2[offs] + dP5[offs];
//		}
//
//		// U4 + P3 -> U5 (=T3=S4=U2), C12
//		double[] dU5 = dU2;
//		for (int i = 0, offsC12 = offsC + sdim2, offs = 0; i < sdim2; i++)  {
//			for (int j = 0; j < sdim2; j++, offs++)	 dU5[offs] = dC[offsC12++] = dU4[offs] + dP3[offs];
//			offsC12 += skipC; 
//		}
//
//		// U3 - P4 -> C21
//		for (int i = 0, offsC21 = offsC + hoffsC, offs = 0; i < sdim2; i++)  {
//			for (int j = 0; j < sdim2; j++, offs++)	dC[offsC21++] = dU3[offs] - dP4[offs];
//			offsC21 += skipC;
//		}
//
//		// U3 + P5 -> C22
//		for (int i = 0, offsC22 = offsC + hoffsC + sdim2, offs = 0; i < sdim2; i++)  {
//			for (int j = 0; j < sdim2; j++, offs++)	dC[offsC22++] = dU3[offs] + dP5[offs];
//			offsC22 += skipC; 
//		}
//		
//		Matrix.mulAdopsSW_DEBUG += (23 + sdim2 * 31);
//	}





	// conditioning for precision and iterative methods: swap in the largest elements of rows into diagonal positions
	// the constant vector c needs to be swapped as well, if set to null it is ignored
	// method constructs array "mutator" with the mutated indexes for facilitating reconstitution of the solved vector
	public void conditionDiagonal(Matrix c, boolean swapMethod, boolean doBitImage) {
		
		if (M != N)									throw new RuntimeException("Matrix.conditionDiagonal(): Matrix not square.");
		if (M < 1)									throw new RuntimeException("Matrix.conditionDiagonal(): Invalid matrix.");
		if (c != null && (M != c.M || c.N != 1))	throw new RuntimeException("Matrix.conditionDiagonal(): Invalid constant vector.");
				
		double[] data = this.data, newdata = new double[M*N];
		if (swapMethod) {
			mutator = new int[M + 1];
			for (int i = 0; i < M; i++) mutator[i] = i;
		}
		
		for (int r1 = 0, m; r1 < M; r1++) {
			int r1N = r1 * N;
			double a_r1r1 = data[r1N + r1];
			if (a_r1r1 < 0) a_r1r1 = -a_r1r1;
			// find largest (absolute) element in current row (skip checking previous rows for swapMethod)
			if (swapMethod) {
				// apply method that swaps row r1 & row r2 if diagonals of both rows get larger on swapping 
				for (int r2 = 0; r2 < N; r2++) {
					if (r1 != r2) {
					int r2N = r2 * N;

					double a_r2r1 = data[r2N + r1], a_r1r2 = data[r1N + r2], a_r2r2 = data[r2N + r2];
					if ((a_r1r1 < a_r2r1 || a_r1r1 > -a_r2r1) && (a_r1r2 >= a_r2r2 || a_r1r2 <= -a_r2r2)) {
						swap(r1, r2);
						if (c != null) c.swap(r1, r2);	// swap matching elements in vector c
						m = mutator[r1];				// swap indexes in mutator array
						mutator[r1] = mutator[r2];
						mutator[r2] = m;
					}
					}
				}
			} else {
				// apply adding method which adds row r2 to r1 if it provides a larger value for diagonal element of row r1
				int rMaxDiag = 0;
				double vMaxDiag = 0;
				// find the largest diagonal from all other rows than r1
				for (int r2 = 0; r2 < N; r2++) {
					if (r2 != r1) {
						double a_r2r1 = data[r2 * N + r1];
						if (a_r2r1 < 0) a_r2r1 = -a_r2r1;
						if (vMaxDiag < a_r2r1) {
							rMaxDiag = r2;
							vMaxDiag = a_r2r1;
						}
					}
				}
				// move over into newdata the row with max-value in diagonal element position added with row of the current diagonal element
				//if (vMaxDiag > a_r1r1) {
					int rMax = rMaxDiag * N;
					for (int c1 = 0; c1 < N; c1++) {
						newdata[r1N + c1] += data[r1N + c1] + data[rMax + c1];
						if (c != null) c.data[r1] += c.data[rMaxDiag];
					}
				//}
			}
		}
		if (!swapMethod) this.data = newdata;
		if (DEBUG_LEVEL > 1) System.out.println("conditionDiagonal():\n" + toString());
		if (doBitImage) bitImage.make();
	}
